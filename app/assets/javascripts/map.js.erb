var geocoder;
var map;
var pinLayer;
var infoboxLayer;
var pushpinFrameHTML;
var currentPinInfobox;

function initialize()
{
    map = new Microsoft.Maps.Map(document.getElementById("mapDiv"), {
		credentials:"AkL7bdBJmEpRncJpZ9MmXwEUIvnkId7Yo9IJrDhNFGrkR--08hfritan5JH_nzRw",
		center: new Microsoft.Maps.Location(37.7577,-122.4376),
		mapTypeId: Microsoft.Maps.MapTypeId.road,
		zoom: 6});
	
	geocoder = new google.maps.Geocoder();
		
	//Create two layers, one for pushpins, the other for the infobox. This way the infobox will always be above the pushpins.
	infoboxLayer = new Microsoft.Maps.EntityCollection();
	map.entities.push(infoboxLayer);
	
	pinLayer = new Microsoft.Maps.EntityCollection();
	map.entities.push(pinLayer);
	
	pushpinFrameHTML = '<div class="infobox"><div class="infobox_content">{content}</div></div><div class="infobox_pointer"><img src= <%= asset_path("pointer_shadow.png") %> /></div>';
}

// on-the-fly call for an address / marker mapping
function addMarkersForLocations(locations) {
	console.log('geocoding locations and adding markers...');
	
	for(address in locations){
		if(locations.hasOwnProperty(address)){
			residents = locations[address];
			if (typeof residents !== "undefined") {
				geocodeAndAddPin(address, residents);
			}
		}
	}
}

function geocodeAndAddPin(address, residents) {
	geocoder.geocode( { 'address': address}, function(results, status) {
    	if (status == google.maps.GeocoderStatus.OK) {
			var lat = results[0].geometry.location.Xa;
			var lng = results[0].geometry.location.Ya;
			var loc = new Microsoft.Maps.Location(lat, lng);
			var pin = new Microsoft.Maps.Pushpin(loc);
			pin.title = address;
			pin.description = residents;
			pinLayer.push(pin);
			
			// Create the infobox for the pushpin
	        var pinInfobox = new Microsoft.Maps.Infobox(pin.getLocation(), {visible:false});
			infoboxLayer.push(pinInfobox);
			currentPinInfobox = pinInfobox;

			 // Add handler for the pushpin click event.
	         Microsoft.Maps.Events.addHandler(pin, 'click', displayInfobox.bind(pinInfobox));

	         // Hide the infobox when the map is moved.
	         Microsoft.Maps.Events.addHandler(map, 'viewchange', function displayInfobox(e)
				{
					this.setOptions({ visible:false });
				}.bind(pinInfobox));
				
			// Hide infobox when anywhere on map is clicked
			Microsoft.Maps.Events.addHandler(map, 'click', function displayInfobox(e)
				{
					this.setOptions({ visible:false });
				}.bind(pinInfobox));

			map.entities.push(pin);
			map.entities.push(pinInfobox);
			
			//document.getElementById("current_friends").innerHTML = numFriends;
	    }
		else if (status == google.maps.GeocoderStatus.OVER_QUERY_LIMIT ||
				status == google.maps.GeocoderStatus.ZERO_RESULTS) {
			setTimeout(function() {
				geocodeAndAddPin(address, residents);
			}, 200);	
		}
		else {
	      alert("Geocode was not successful for the following reason: " + status);
	    }
  });
}

function displayInfobox(e)
{
	if (e.targetType == "pushpin") {
		currentPinInfobox.setOptions({visible: false});
		currentPinInfobox = this;
		
		var pin = e.target;
		var html = "<span class='infobox_title'>" + pin.title + "</span><br/>" + pin.description;

		this.setOptions({
			visible:!this.getVisible(),
			offset: new Microsoft.Maps.Point(-33,20),
			htmlContent: pushpinFrameHTML.replace('{content}',html)
		});

		//set location of infobox
		this.setLocation(pin.getLocation());
    }

}                    

function hideInfobox()
{
	this.setOptions({ visible: false });
}

function replaceWhiteSpace(str) {
	return str.replace(/\s/g,'').replace(/\,/g,''); 
}

// function addMarkersForLocations(locations) {
// 	$.ajax({
// 		    url: "/locations",
// 		    type: "POST",
// 		    data: {locations: JSON.stringify(locations)},
// 		    success: function(resp){
// 				console.log('locations posted');
// 				console.log(resp);
// 				if (resp) {
// 					for (var i=0; i < resp.length; i++) {
// 						//location = resp[1];
// 						//addMarker(location.city, location.lat, location.lng);
// 					}	
// 				}
// 			}
// 		});
// 	for(var i=0; i<locations.length; i++) {
// 		codeAddress(locations[i].city);
// 	}
// }
